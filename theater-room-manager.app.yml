name: theater-room-manager
version: "1.0"
services:
  - name: theater-operations
    variables:
      - name: OPERATIONS_USERNAME
        value-from-vault-secret:
          vault: operations
          secret: credentials
          key: username
    containers:
      - name: projector-operations
        image: "registry.gitlab.com/avassa-public/movie-theaters-demo/projector-operations:v1.0"
      - name: digital-assets-manager
        image: "registry.gitlab.com/avassa-public/movie-theaters-demo/digital-assets-manager:v1.0"
        env:
          USERNAME: ${OPERATIONS_USERNAME}
        mounts:
          - volume-name: credentials
            mount-path: /credentials
    volumes:
      - name: credentials
        vault-secret:
          vault: operations
          secret: credentials
    mode: replicated
    replicas: 1
  - name: curtain-controller
    containers:
      - name: curtain-controller
        image: "registry.gitlab.com/avassa-public/movie-theaters-demo/curtain-controller:v1.0"
    mode: replicated
    replicas: 1
  - name: log-exporter
    variables:
      - name: AWS_ACCESS_KEY_ID
        value-from-vault-secret:
          vault: operations
          secret: credentials
          key: AWS-ACCESS-KEY-ID
      - name: AWS_SECRET_ACCESS_KEY
        value-from-vault-secret:
          vault: operations
          secret: credentials
          key: AWS-SECRET-ACCESS-KEY
    containers:
      - name: fluent-bit
        # You may want to consider locking this to a particual version in production
        image: registry.gitlab.com/avassa-public/fluent-bit/fluent-bit:latest
        approle: fluent-bit
        mounts:
          - volume-name: cfg
            files:
              - name: fluent-bit.conf
                mount-path: /fluent-bit/etc/fluent-bit.conf
        env:
          APPROLE_SECRET_ID: "${SYS_APPROLE_SECRET_ID}"
          AWS_ACCESS_KEY_ID: "${AWS_ACCESS_KEY_ID}"
          AWS_SECRET_ACCESS_KEY: "${AWS_SECRET_ACCESS_KEY}"

